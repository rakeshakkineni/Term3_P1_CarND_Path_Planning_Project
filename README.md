# Path Planning Project

## **Path Planning Project**

The goals / steps of this project are the following:
* Modify the code to design a path planner that is able to create smooth, safe paths for the car to follow along a 3 lane highway with traffic.
* Car should drive smoothly , should not collide with vehciles , should be able to change lanes in slow traffic situation and should not exceed the speed limit. 


[//]: # (Image References)

[image1]: ./Output/Graphical_Image.png 
[image2]: ./Output/Px_RMSE.png 
[image3]: ./Output/Py_RMSE.png
[image4]: ./Output/Vx_RMSE.png
[image5]: ./Output/Vy_RMSE.png


---
### Writeup / README
Source code provided by "CarND-Path-Planning-Project" was used as base for this project and UDACITY term3_sim was used to check the code performance. 

### Modifications
File main.cpp was modified to implement this project. Majority of the changes are part of "int main()" function and a new function "vector<int> successor_lane(int curr_lane)". Code for this project can be found [here] ("./CarND-Extended-Kalman-Filter-Project-Modified.zip")

### Development Steps and Code Flow
I have started with code shown in Project Walkthrough video. I have implemented a strategy to check the adjacent lanes for vehicles very close to the EGO Vehicle before changing the lanes. 

#### Overview:
To drive the vehicle autonomously simulator expects a set of points with X,Y coordinates to be sent to it. I send 50 coordinates each time simulator waits for inputs from code. 

Simulator provides list of coordinates that are not yet used , when the simulator is started this list will not have any values, so current car position and previous position that is tangential to current car poistion are used as starting point. If it is not the starting point then last 2 coordinates in the list provided by the simulator as used as starting point. Source Code Line No 381- 411 implement this. 

To the starting point list 3 additional points that are at 30,60,90 meters away from current car S coordinates are added, here Lane information is also used, the resultant list is transformed to vehicle coordinates. Source Code Line No 413- 423 implement this. 

From this list using spline equidistant points are generated and are converted to global coordinate system. Spline points are generated by assuming a target distance of 30 mts and by considering the expected vehicle speed (ref_vel). Source Code Line No 437- 490 implement this. 

To avoid jerky movement of the vehicle all the coordinates that simulator provided are added to the new list, this list shall be less than 50 points, the remaining points are added from the list that was generated using spline. Source Code Line No 446- 450 and 460-490 implement this.  

Using the sensor fusion data list of vehicles that are in current lane are identfied and if the distanc between EGO Vehicle and the vehicle in current lane is less than 30mts then EGO Vehicle speed (ref_vel) is reduced by 0.224m/s for every spline point generated. If there is no vehicle infornt of the EGO Vehicle within 30mts and EGO Vehicle speed is less than 49Mi/h EGO Vehicle speed (ref_vel) is increased by 0.224m/s for every spline point generated.Source Code Line No 278-297 and 462- 469 implement this. 

A lane change strategy was implemented if the EGO vehicle is moving at slow speed due to a slow moving vehicle in the front. To acheive this first all the possible lane shifts are identified using the function successor_lane(int), this function shall accept current lane as input and return a vector of possible future lanes following are the details of this function. 
  - Current Lane = Middle Lane, Next Lanes = Left or Right Lane
  - Current Lane = Left Lane, Next Lanes = Middle Lane
  - Current Lane = Right Lane, Next Lanes = Middle Lane
Source Code Line No 167- 187 implement this.

"succesor_lane" function does not check if there any vehicles very close to current vehicle position in the function lanes. To check if there are any cars in these next lanes Sensor_Fusion data is used and closest vehicle in the front and rear of the EGO vehicle in the next lanes are identified all this comparision is done in Fernet Coordinates, for all this calculation current S position of the EGO Vehicle is used. Lane with largest gap and no vehicle with in 30mts in the front and 10mts in rear is select as next lane. If there is no there is no lane that matches these requirements EGO Vehicle shall continue to be in the same lane. The points that are generated at 30,60,90mts use the lane information for generating X,Y coordinates. 
Source Code Line No 299- 372 implement this. 

#### Rubic: The car drives according to the speed limit
A variable ref_vel is used for controling the vehicle speed and a maximum limit of 49Mi/h is set. ref_vel is used in generating the spline points. Line number 466 implements this. 

#### Rubic: Max Acceleration and Jerk are not Exceeded
Vehicle always starts from 0 vehicle speed, to avoid jerky movement vehicle speed is slowly increased. This control implemented on each generated waypoint. Speed is increased/ decreased by only 0.224m/s each time. An increment or decrement of speed by 0.224m/s does not exceed the 10m/s^2 limit of acceleration. Line number 462-469 implements this. 

#### Rubic: Max Acceleration and Jerk are not Exceeded

### Output
Kalman Filter was able to estimate the position of the vehicle. 

- In the following picture the estimated path followed by the vehicle is in green. 

![alt text][image1]

- RMSE for each scan is printed in a text file. Using the printed data graphs were ploted to understand the trend of the RMSE for each parameter. 

![alt text][image2]

![alt text][image3]

![alt text][image4]

![alt text][image5]

## Result:
Initially all the parameters start with a huge RMSE value but eventually RMSE values for all the parameters fall below Rubics criteria. 
